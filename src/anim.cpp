//
// Created by Jake Stover on 4/24/18.
//

#include <teem/nrrd.h>
#include "anim.h"
#include "util.h"


void setup_anim(CLI::App &app) {
  auto opt = std::make_shared<AnimOptions>();
  auto sub = app.add_subcommand("anim", "Create animations from projection .nrrd files generated by skim.");

  sub->add_option("-t, --tmax", opt->tmax, "Number of projection files.")->required();
  sub->add_option("-p, --proj", opt->proj_path, "Where projection files are. (Default: proj/)");
  sub->add_option("-o, --anim", opt->anim_path, "Where to output anim files. (Default: anim/)");
  sub->add_option("-d, --dsample", opt->dwn_sample, "Amount by which to down-sample the data. (Default: 1)");
  sub->add_option("-x, --scalex", opt->scale_x, "Scaling on the x axis. (Default: 1.0)");
  sub->add_option("-z, --scalez", opt->scale_z, "Scaling on the z axis. (Default: 1.0)");
  sub->add_option("-v, --verbose", opt->verbose, "Print processing message or not. (Default: 0(close))");

  sub->set_callback([opt]() { 
    try{
      Anim(*opt).main();
    }
    catch(LSPException &e){
      std::cerr << "Exception thrown by " << e.get_func() << "() in " << e.get_file() << ": " << e.what() << std::endl;
    }
  });
}


Anim::Anim(AnimOptions const &opt): opt(opt), mop(airMopNew()) {

  max_x_frames = std::vector<Nrrd*>();
  max_z_frames = std::vector<Nrrd*>();
  avg_x_frames = std::vector<Nrrd*>();  
  avg_z_frames = std::vector<Nrrd*>();

}


Anim::~Anim() {
  airMopOkay(mop);
}


void Anim::split_type(){

  double resample_xy = opt.scale_x / opt.scale_z / opt.dwn_sample;
  double resample_z = 1.0 / opt.dwn_sample;

  if(opt.verbose){
    std::cout << "Spliting nrrd on type dimension..." << std::endl;
    std::cout << "Resampling Factors: resample_xy = " << resample_xy << ", resample_z = " << resample_z << std::endl;
  }

  // slice and resample projection files
  for(int i = 0; i <= opt.tmax; i++) {
    std::string iii = zero_pad(i, 3);

    if(opt.verbose)
      std::cout << std::endl << "===== " << iii << "/" << opt.tmax << "=====================" << std::endl;

    std::string xy_proj_file = opt.proj_path + iii + "-projXY.nrrd";
    std::string yz_proj_file = opt.proj_path + iii + "-projYZ.nrrd";

    Nrrd* xy_proj = safe_nrrd_load(mop, xy_proj_file);
    Nrrd* yz_proj = safe_nrrd_load(mop, yz_proj_file);

    Nrrd* res_rsm[2][2]; //store {{max_z, avg_z}, {max_x, avg_x}}

    Nrrd* proj_rsm[2] = {safe_nrrd_load(mop, xy_proj_file),
                         safe_nrrd_load(mop, yz_proj_file)};
    double resample_rsm[2] = {resample_z, resample_xy};
    double kparm[2] = {0, 0.5};
    for(auto i=0; i<2; ++i){
      auto rsmc = nrrdResampleContextNew();
      airMopAdd(mop, rsmc, (airMopper)nrrdResampleContextNix, airMopAlways);

      nrrd_checker(nrrdResampleInputSet(rsmc, proj_rsm[i]) ||
                      nrrdResampleKernelSet(rsmc, 0, nrrdKernelBCCubic, kparm) ||
                      nrrdResampleSamplesSet(rsmc, 0, size_t(ceil(proj_rsm[i]->axis[0].size*resample_rsm[i]))) ||
                      nrrdResampleRangeFullSet(rsmc, 0) ||
                      nrrdResampleBoundarySet(rsmc, nrrdBoundaryBleed) ||
                      nrrdResampleRenormalizeSet(rsmc, AIR_TRUE) ||
                      nrrdResampleKernelSet(rsmc, 1, nrrdKernelBCCubic, kparm) ||
                      nrrdResampleSamplesSet(rsmc, 1, size_t(ceil(proj_rsm[i]->axis[1].size*resample_rsm[i]))) ||
                      nrrdResampleRangeFullSet(rsmc, 1) ||
                      nrrdResampleKernelSet(rsmc, 2, NULL, NULL) ||
                      nrrdResampleKernelSet(rsmc, 3, NULL, NULL) ||
                      nrrdResampleExecute(rsmc, proj_rsm[i]),
                  mop, "Error resampling nrrd: ", "anim.cpp", "Anim::split_type");

      //TODO SWAP(AX0 AX1) ifor xy plane
      
      nrrd_checker(nrrdSlice(res_rsm[i][0], proj_rsm[i], 3, 0) ||
                      nrrdSlice(res_rsm[i][1], proj_rsm[i], 3, 1),
                  mop, "Error slicng nrrd: ", "anim.cpp", "Anim::split_type");
    }

    max_z_frames.push_back(res_rsm[0][0]);
    avg_z_frames.push_back(res_rsm[0][1]);
    max_x_frames.push_back(res_rsm[1][0]);
    avg_x_frames.push_back(res_rsm[1][1]);
  }
}


void Anim::make_max_frame(std::vector<Nrrd*> frame){
  Nrrd* joined = safe_nrrd_new(mop, (airMopper)nrrdNuke);
  Nrrd* tmp0 = safe_nrrd_new(mop, (airMopper)nrrdNuke);
  Nrrd* tmp1 = safe_nrrd_new(mop, (airMopper)nrrdNuke);

  //join along time, slice along channel
  nrrd_checker(nrrdJoin(joined,frame.data(), frame.size(), 3, 0) ||
                nrrdSlice(tmp0, joined, 2, 0) ||
                nrrdSlice(tmp1, joined, 2, 1),
              mop, "Error joining/slicing nrrd: ", "anim.cpp", "Anim::make_max_frame");
  //quantize to 8bit
  auto range = nrrdRangeNew(AIR_NAN, AIR_NAN);
  airMopAdd(mop, range, (airMopper)nrrdRangeNix, airMopAlways);
  nrrd_checker(nrrdRangePercentileFromStringSet(range, tmp0, "0.02%", "5%", 5000, true) ||
                nrrdQuantize(tmp0, tmp0, range, 8),
              mop, "Error quantizing nrrd: ", "anim.cpp", "Anim::make_max_frame");

  //set brightness for ch2(and quantize to 8bit)
  nrrd_checker(nrrdArithGamma(tmp1, tmp1, NULL, 3) ||
                  nrrdRangePercentileFromStringSet(range, tmp1, "0.01%", "5%", 5000, true) ||
                  nrrdQuantize(tmp1, tmp1, range, 8),
              mop, "Error quantizing nrrd: ", "anim.cpp", "Anim::make_max_frame");
    
  //slice on time and output
  for (size_t t = 0; t < frame.size(); ++t) {
    Nrrd* tmp0_t = safe_nrrd_new(mop, (airMopper)nrrdNuke);
    Nrrd* tmp1_t = safe_nrrd_new(mop, (airMopper)nrrdNuke);
    std::string x_name = opt.anim_path + zero_pad(t, 3) + "-max-" + "x-" + std::to_string(t) + ".ppm";
    std::string z_name = opt.anim_path + zero_pad(t, 3) + "-max-" + "z-" + std::to_string(t) + ".ppm";

    if(opt.verbose)
      std::cout << "Output " << t << "/" << opt.tmax << "max_frames" << std::endl;

    nrrd_checker(nrrdSlice(tmp0, tmp0_t, 2, t)  ||
                  nrrdSlice(tmp1, tmp1_t, 2, t) ||
                  nrrdSave(x_name.c_str() , tmp0_t, nullptr) ||
                  nrrdSave(z_name.c_str() , tmp1_t, nullptr),
                mop, "Error saving ppm files: ", "anim.cpp", "Anim::make_max_frame");
  }
}


void Anim::make_avg_frame(std::vector<Nrrd*> frame){
  Nrrd* joined = safe_nrrd_new(mop, (airMopper)nrrdNuke);
  Nrrd* tmp = safe_nrrd_new(mop, (airMopper)nrrdNuke);

  //join along time, slice along channel
  nrrd_checker(nrrdJoin(joined,frame.data(), frame.size(), 3, 0),
              mop, "Error joining/slicing nrrd: ", "anim.cpp", "Anim::make_avg_frame");
  //resample: gaussian blur
  auto rsmc = nrrdResampleContextNew();
  airMopAdd(mop, rsmc, (airMopper)nrrdResampleContextNix, airMopAlways);

  double kparm[2] = {40,3};
  nrrd_checker(nrrdResampleInputSet(rsmc, joined) ||
                  nrrdResampleKernelSet(rsmc, 0, nrrdKernelGaussian, kparm) ||
                  nrrdResampleSamplesSet(rsmc, 0, joined->axis[0].size) ||
                  nrrdResampleRangeFullSet(rsmc, 1) ||
                  nrrdResampleBoundarySet(rsmc, nrrdBoundaryBleed) ||
                  nrrdResampleRenormalizeSet(rsmc, AIR_TRUE) ||
                  nrrdResampleKernelSet(rsmc, 1, nrrdKernelGaussian, kparm) ||
                  nrrdResampleSamplesSet(rsmc, 1, joined->axis[1].size) ||
                  nrrdResampleRangeFullSet(rsmc, 1) ||
                  nrrdResampleKernelSet(rsmc, 2, NULL, NULL) ||
                  nrrdResampleKernelSet(rsmc, 3, NULL, NULL) ||
                  nrrdResampleExecute(rsmc, tmp),
              mop,  "Error resampling nrrd: ", "anim.cpp", "Anim::make_avg_frame");

  //slice on ch 
  Nrrd* tmp0 = safe_nrrd_new(mop, (airMopper)nrrdNuke);
  Nrrd* tmp1 = safe_nrrd_new(mop, (airMopper)nrrdNuke);

  NrrdIter* nit1 = nrrdIterNew();
  airMopAdd(mop, nit1, airMopper(nrrdIterNix), airMopAlways);
  NrrdIter* nit2 = nrrdIterNew();
  airMopAdd(mop, nit2, airMopper(nrrdIterNix), airMopAlways);

  nrrdIterSetOwnNrrd(nit1, tmp);
  nrrdIterSetValue(nit2, 0.5);

  nrrdArithIterBinaryOp(tmp, nrrdBinaryOpMultiply, nit1, nit2);

  nrrdIterSetOwnNrrd(nit1, tmp);
  nit2 = nrrdIterNix(nit2);
  nrrdIterSetOwnNrrd(nit2, joined);

  nrrdArithIterBinaryOp(joined, nrrdBinaryOpSubtract, nit2, nit1);

  nrrdSlice(tmp0, joined, 2, 0);
  nrrdSlice(tmp1, joined, 2, 1);

  //quantize to 8bit
  auto range = nrrdRangeNew(AIR_NAN, AIR_NAN);
  airMopAdd(mop, range, (airMopper)nrrdRangeNix, airMopAlways);
  nrrd_checker(nrrdRangePercentileFromStringSet(range, tmp0, "0.02%", "5%", 5000, true) ||
                nrrdQuantize(tmp0, tmp0, range, 8) ||
                nrrdRangePercentileFromStringSet(range, tmp1, "0.02%", "5%", 5000, true) ||
                nrrdQuantize(tmp1, tmp1, range, 8),
              mop, "Error quantizing nrrd: ", "anim.cpp", "Anim::make_avg_frame");

  //slice on time and output
  for (size_t t = 0; t < frame.size(); ++t) {
    Nrrd* tmp0_t = safe_nrrd_new(mop, (airMopper)nrrdNuke);
    Nrrd* tmp1_t = safe_nrrd_new(mop, (airMopper)nrrdNuke);
    std::string x_name = opt.anim_path + zero_pad(t, 3) + "-avg-" + "x-" + std::to_string(t) + ".ppm";
    std::string z_name = opt.anim_path + zero_pad(t, 3) + "-avg-" + "z-" + std::to_string(t) + ".ppm";

    if(opt.verbose)
      std::cout << "Output " << t << "/" << opt.tmax << "avg_frames" << std::endl;

    nrrd_checker(nrrdSlice(tmp0, tmp0_t, 2, t)  ||
                  nrrdSlice(tmp1, tmp1_t, 2, t) ||
                  nrrdSave(x_name.c_str() , tmp0_t, nullptr) ||
                  nrrdSave(z_name.c_str() , tmp1_t, nullptr),
                mop, "Error saving ppm files: ", "anim.cpp", "Anim::make_avg_frame");
  }
}


void Anim::assembling_frame() {
  if(opt.verbose)
    std::cout << "Assembling frames..." << std::endl;

  for(auto type: {"max", "avg"}){
    for(auto i=0; i<=opt.tmax; ++i){
      std::string base_path = opt.anim_path + zero_pad(i, 3) + "-" + type;
      Nrrd *ppm_z_0 = safe_nrrd_load(mop, base_path + "-z-0.ppm");
      Nrrd *ppm_z_1 = safe_nrrd_load(mop, base_path + "-z-1.ppm");
      Nrrd *ppm_x_0 = safe_nrrd_load(mop, base_path + "-x-0.ppm");
      Nrrd *ppm_x_1 = safe_nrrd_load(mop, base_path + "-x-1.ppm");
      std::vector<Nrrd*> ppms = {ppm_z_1, ppm_z_0, ppm_z_1, ppm_x_1, ppm_x_0, ppm_x_1};

      Nrrd *nout = safe_nrrd_new(mop, (airMopper)nrrdNuke);
      nrrd_checker(nrrdJoin(nout, ppms.data(), ppms.size(), 0, 1) ||
                    nrrdJoin(nout, &nout, 1, 1, 1),
                  mop, "Error joining ppm files to png: ", "anim.cpp", "Anim::assembling_frame");
      std::string out_name = base_path + "-" + type + ".png";
      nrrd_checker(nrrdSave(out_name.c_str(), nout, nullptr), 
                  mop, "Error saving png file: ", "anim.cpp", "Anim::assembling_frame");
    }
  }
}


void Anim::main(){

  split_type();

  if(opt.verbose)
    std::cout << "Making frames for max channel..." << std::endl;
  make_max_frame(max_x_frames);
  make_max_frame(max_z_frames);

  if(opt.verbose)
    std::cout << "Making frames for max channel..." << std::endl;
  make_avg_frame(avg_x_frames);
  make_avg_frame(avg_z_frames);

  assembling_frame();
}