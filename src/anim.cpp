//
// Created by Jake Stover on 4/24/18.
//

#include <teem/nrrd.h>
#include "anim.h"
#include "util.h"


void setup_anim(CLI::App &app) {
  auto opt = std::make_shared<AnimOptions>();
  auto sub = app.add_subcommand("anim", "Create animations from projection .nrrd files generated by skim.");

  sub->add_option("-n, --name", opt->name, "Basename to be used for final animations.")->required();
  sub->add_option("-t, --tmax", opt->tmax, "Number of projection files.")->required();
  sub->add_option("-d, --dsample", opt->dwn_sample, "Amount by which to down-sample the data.")->required();
  sub->add_option("-x, --scalex", opt->scale_x, "Scaling on the x axis.")->required();
  sub->add_option("-z, --scalez", opt->scale_z, "Scaling on the z axis.")->required();

  sub->set_callback([opt]() { anim_main(*opt); });
}

void
nrrdRangeSet1(NrrdRange *range, const Nrrd *nrrd, int blind8BitRange) {
  NRRD_TYPE_BIGGEST _min, _max;
  int blind;

  if (!range) {
    return;
  }
  if (nrrd
      && !airEnumValCheck(nrrdType, nrrd->type)
      && nrrdTypeBlock != nrrd->type) {
    std::cout << 1 << std::endl;
    blind = (nrrdBlind8BitRangeTrue == blind8BitRange
             || (nrrdBlind8BitRangeState == blind8BitRange
                 && nrrdStateBlind8BitRange));
    if (blind && 1 == nrrdTypeSize[nrrd->type]) {
      std::cout << 2 << std::endl;
      if (nrrdTypeChar == nrrd->type) {
        std::cout << 3 << std::endl;
        range->min = SCHAR_MIN;
        range->max = SCHAR_MAX;
      } else {
        std::cout << 4 << std::endl;
        range->min = 0;
        range->max = UCHAR_MAX;
      }
      range->hasNonExist = nrrdHasNonExistFalse;
    } else {
      std::cout << 5 << std::endl;
      nrrdMinMaxExactFind[nrrd->type](&_min, &_max, &(range->hasNonExist),
                                      nrrd);
      range->min = nrrdDLoad[nrrd->type](&_min);
      range->max = nrrdDLoad[nrrd->type](&_max);
    }
  } else {
    std::cout << 6 << std::endl;
    range->min = range->max = AIR_NAN;
    range->hasNonExist = nrrdHasNonExistUnknown;
  }
  return;
}


int anim_main(AnimOptions const &opt) {
  std::string name = opt.name;
  uint tmax = opt.tmax;
  float down_sample = opt.dwn_sample;
  float scale_x = opt.scale_x;
  float scale_z = opt.scale_z;

  float resample_xy = scale_x / scale_z / down_sample;
  float resample_z = 1.0 / down_sample;

  auto mop = airMopNew();

  std::cout << "Resampling Factors: resample_xy = " << resample_xy << ", resample_z = " << resample_z << std::endl;

  auto max_x_frames = std::vector<Nrrd*>();
  auto max_z_frames = std::vector<Nrrd*>();
  auto avg_x_frames = std::vector<Nrrd*>();  
  auto avg_z_frames = std::vector<Nrrd*>();

  Nrrd* max_x_time = nrrdNew();
  Nrrd* max_z_time = nrrdNew();
  Nrrd* avg_x_time = nrrdNew();
  Nrrd* avg_z_time = nrrdNew();

  // slice and resample projection files
  for(int i = 100; i <= tmax; i++) {
    std::string iii = zero_pad(i, 3);

    std::cout << std::endl << "===== " << iii << "/" << tmax << "=====================" << std::endl;

    std::string xy_proj_file = "proj/" + iii + "-projXY.nrrd";
    std::string yz_proj_file = "proj/" + iii + "-projYZ.nrrd";
    std::string max_z_file = "anim/" + iii + "-max-z.nrrd";
    std::string max_x_file = "anim/" + iii + "-max-x.nrrd";
    std::string avg_z_file = "anim/" + iii + "-avg-z.nrrd";
    std::string avg_x_file = "anim/" + iii + "-avg-x.nrrd";


    Nrrd* xy_proj = safe_load_nrrd(xy_proj_file);
    airMopAdd(mop, xy_proj, airMopper(nrrdNuke), airMopAlways);

    Nrrd* yz_proj = safe_load_nrrd(yz_proj_file);
    airMopAdd(mop, yz_proj, airMopper(nrrdNuke), airMopAlways);

    auto rsmc = nrrdResampleContextNew();
    airMopAdd(mop, rsmc, (airMopper)nrrdResampleContextNix, airMopAlways);

    double kparm[2] = {0, 0.5};
    if (nrrdResampleInputSet(rsmc, xy_proj) ||
        nrrdResampleKernelSet(rsmc, 0, nrrdKernelBCCubic, kparm) ||
        nrrdResampleSamplesSet(rsmc, 0, size_t(ceil(xy_proj->axis[0].size*resample_xy))) ||
        nrrdResampleRangeFullSet(rsmc, 0) ||
        nrrdResampleBoundarySet(rsmc, nrrdBoundaryBleed) ||
        nrrdResampleRenormalizeSet(rsmc, AIR_TRUE) ||
        nrrdResampleKernelSet(rsmc, 1, nrrdKernelBCCubic, kparm) ||
        nrrdResampleSamplesSet(rsmc, 1, size_t(ceil(xy_proj->axis[1].size*resample_xy))) ||
        nrrdResampleRangeFullSet(rsmc, 1) ||
        nrrdResampleKernelSet(rsmc, 2, NULL, NULL) ||
        nrrdResampleKernelSet(rsmc, 3, NULL, NULL) ||
        nrrdResampleExecute(rsmc, xy_proj)) {
      char *msg;
      char *err = biffGetDone(NRRD);

      sprintf(msg, "Error resampling nrrd: %s", err);

      airMopAdd(mop, err, airFree, airMopAlways);
      airMopError(mop);

      throw LSPException(msg, "anim.cpp", "anim");
    }

    Nrrd* max_z = nrrdNew();
    airMopAdd(mop, max_z, airMopper(nrrdNix), airMopAlways);
    Nrrd* avg_z = nrrdNew();
    airMopAdd(mop, avg_z, airMopper(nrrdNix), airMopAlways);

    nrrdSlice(max_z, xy_proj, 3, 0);
    nrrdSlice(avg_z, xy_proj, 3, 1);

    if (nrrdResampleInputSet(rsmc, yz_proj) ||
        nrrdResampleKernelSet(rsmc, 0, nrrdKernelBCCubic, kparm) ||
        nrrdResampleSamplesSet(rsmc, 0, size_t(ceil(yz_proj->axis[1].size*resample_xy))) ||
        nrrdResampleRangeFullSet(rsmc, 0) ||
        nrrdResampleBoundarySet(rsmc, nrrdBoundaryBleed) ||
        nrrdResampleRenormalizeSet(rsmc, AIR_TRUE) ||
        nrrdResampleKernelSet(rsmc, 1, nrrdKernelBCCubic, kparm) ||
        nrrdResampleSamplesSet(rsmc, 1, size_t(ceil(yz_proj->axis[1].size*resample_z))) ||
        nrrdResampleRangeFullSet(rsmc, 1) ||
        nrrdResampleKernelSet(rsmc, 2, NULL, NULL) ||
        nrrdResampleKernelSet(rsmc, 3, NULL, NULL) ||
        nrrdResampleExecute(rsmc, yz_proj)) {
      char *msg;
      char *err = biffGetDone(NRRD);

      sprintf(msg, "Error resampling nrrd: %s", err);

      airMopAdd(mop, err, airFree, airMopAlways);
      airMopError(mop);

      throw LSPException(msg, "anim.cpp", "anim");
    }

    nrrdAxesSwap(yz_proj, yz_proj, 0, 1);

    Nrrd* max_x = nrrdNew();
    airMopAdd(mop, max_x, airMopper(nrrdNix), airMopAlways);
    Nrrd* avg_x = nrrdNew();
    airMopAdd(mop, avg_x, airMopper(nrrdNix), airMopAlways);

    nrrdSlice(max_x, yz_proj, 3, 0);
    nrrdSlice(avg_x, yz_proj, 3, 1);

    nrrdSave(max_x_file.c_str(), max_x, NULL);
    nrrdSave(max_z_file.c_str(), max_z, NULL);
    nrrdSave(avg_x_file.c_str(), avg_x, NULL);
    nrrdSave(avg_z_file.c_str(), avg_z, NULL);

    max_x_frames.push_back(max_x);
    max_z_frames.push_back(max_z);
    avg_x_frames.push_back(avg_x);
    avg_z_frames.push_back(avg_z);

  }

  //
  Nrrd* max_x_joined = nrrdNew();
  Nrrd* tmp0 = nrrdNew();
  Nrrd* tmp1 = nrrdNew();
  airMopAdd(mop, max_x_joined, airMopper(nrrdNuke), airMopAlways);
  airMopAdd(mop, tmp0, airMopper(nrrdNuke), airMopAlways);
  airMopAdd(mop, tmp1, airMopper(nrrdNuke), airMopAlways);

  nrrdJoin(max_x_joined, max_x_frames.data(), max_x_frames.size(), 3, 0);

  nrrdSlice(tmp0, max_x_joined, 2, 0);
  nrrdSlice(tmp1, max_x_joined, 2, 1);

  auto range = nrrdRangeNew(AIR_NAN, AIR_NAN);
  airMopAdd(mop, range, (airMopper)nrrdRangeNix, airMopAlways);
nrrdRangeSet1(range, tmp0, true);
  if (nrrdRangePercentileFromStringSet(range, tmp0, "0.02%", "5%", 
                                       5000, true)
      || nrrdQuantize(tmp0, tmp0, range, 8)) {
    char *msg;
    char *err = biffGetDone(NRRD);

    sprintf(msg, "Error quantizing nrrd: %s", err);

    airMopAdd(mop, err, airFree, airMopAlways);
    airMopError(mop);

    throw LSPException(msg, "anim.cpp", "anim");
  }

  auto max_x_q0 = std::vector<Nrrd*>();

  for (size_t i = 0; i < max_x_frames.size(); i++) {
    Nrrd* tmp = nrrdNew();
    airMopAdd(mop, tmp, airMopper(nrrdNuke), airMopAlways);

    nrrdSlice(tmp0, tmp, 2, i);

    max_x_q0.push_back(tmp);
  }

  if (nrrdArithGamma(tmp1, tmp1, NULL, 3) ||
      nrrdRangePercentileFromStringSet(range, tmp1, "0.01%", "5%", 5000, true) ||
      nrrdQuantize(tmp1, tmp1, range, 8)) {
    char *msg;
    char *err = biffGetDone(NRRD);

    sprintf(msg, "Error quantizing nrrd: %s", err);

    airMopAdd(mop, err, airFree, airMopAlways);
    airMopError(mop);

    throw LSPException(msg, "anim.cpp", "anim");
  }
  auto max_x_q = std::vector<Nrrd*>();

  for (size_t i = 0; i < max_x_frames.size(); i++) {
    Nrrd* tmp = nrrdNew();
    airMopAdd(mop, tmp, airMopper(nrrdNuke), airMopAlways);

    nrrdSlice(tmp0, tmp, 2, i);

    max_x_q.push_back(tmp);
  }

  auto max_x_q1 = std::vector<Nrrd*>();

  for (size_t i = 0; i < max_x_frames.size(); i++) {
    Nrrd* tmp = nrrdNew();
    airMopAdd(mop, tmp, airMopper(nrrdNuke), airMopAlways);

    nrrdSlice(tmp1, tmp, 2, i);

    max_x_q1.push_back(tmp);
  }

  Nrrd* avg_x_joined = nrrdNew();
  airMopAdd(mop, avg_x_joined, airMopper(nrrdNuke), airMopAlways);

  nrrdJoin(avg_x_joined, avg_x_frames.data(), avg_x_frames.size(), 3, 0);

  Nrrd* resamp = nrrdNew();
  airMopAdd(mop, resamp, airMopper(nrrdNuke), airMopAlways);

  auto rsmc = nrrdResampleContextNew();
  airMopAdd(mop, rsmc, (airMopper)nrrdResampleContextNix, airMopAlways);

  double kparm[2] = {40,3};
  if (nrrdResampleInputSet(rsmc, avg_x_joined) ||
      nrrdResampleKernelSet(rsmc, 0, nrrdKernelGaussian, kparm) ||
      nrrdResampleSamplesSet(rsmc, 0, avg_x_joined->axis[0].size) ||
      nrrdResampleRangeFullSet(rsmc, 1) ||
      nrrdResampleBoundarySet(rsmc, nrrdBoundaryBleed) ||
      nrrdResampleRenormalizeSet(rsmc, AIR_TRUE) ||
      nrrdResampleKernelSet(rsmc, 1, nrrdKernelGaussian, kparm) ||
      nrrdResampleSamplesSet(rsmc, 1, avg_x_joined->axis[1].size) ||
      nrrdResampleRangeFullSet(rsmc, 1) ||
      nrrdResampleKernelSet(rsmc, 2, NULL, NULL) ||
      nrrdResampleKernelSet(rsmc, 3, NULL, NULL) ||
      nrrdResampleExecute(rsmc, resamp)) {
    char *msg;
    char *err = biffGetDone(NRRD);

    sprintf(msg, "Error resampling nrrd: %s", err);

    airMopAdd(mop, err, airFree, airMopAlways);
    airMopError(mop);

    throw LSPException(msg, "anim.cpp", "anim");
  }

  NrrdIter* nit1 = nrrdIterNew();
  airMopAdd(mop, nit1, airMopper(nrrdIterNix), airMopAlways);
  NrrdIter* nit2 = nrrdIterNew();
  airMopAdd(mop, nit2, airMopper(nrrdIterNix), airMopAlways);

  nrrdIterSetOwnNrrd(nit1, resamp);
  nrrdIterSetValue(nit2, 0.5);

  nrrdArithIterBinaryOp(resamp, nrrdBinaryOpMultiply, nit1, nit2);

  nrrdIterSetOwnNrrd(nit1, resamp);
  nit2 = nrrdIterNix(nit2);
  nrrdIterSetOwnNrrd(nit2, avg_x_joined);

  nrrdArithIterBinaryOp(avg_x_joined, nrrdBinaryOpSubtract, nit2, nit1);

  nrrdSlice(tmp0, avg_x_joined, 2, 0);
  nrrdSlice(tmp1, avg_x_joined, 2, 1);

  range = nrrdRangeNew(AIR_NAN, AIR_NAN);
  airMopAdd(mop, range, (airMopper)nrrdRangeNix, airMopAlways);

  if (nrrdRangePercentileFromStringSet(range, tmp0, "0.1%", "10%", 
                                       5000, true)
      || nrrdQuantize(tmp0, tmp0, range, 8)) {
    char *msg;
    char *err = biffGetDone(NRRD);

    sprintf(msg, "Error quantizing nrrd: %s", err);

    airMopAdd(mop, err, airFree, airMopAlways);
    airMopError(mop);

    throw LSPException(msg, "anim.cpp", "anim");
  }

  auto avg_x_q0 = std::vector<Nrrd*>();

  for (size_t i = 0; i < max_x_frames.size(); i++) {
    Nrrd* tmp = nrrdNew();
    airMopAdd(mop, tmp, airMopper(nrrdNuke), airMopAlways);

    nrrdSlice(tmp0, tmp, 2, i);

    avg_x_q0.push_back(tmp);
  }


  if (nrrdRangePercentileFromStringSet(range, tmp1, "0.1%", "10%", 5000, true) ||
      nrrdQuantize(tmp1, tmp1, range, 8)) {
    char *msg;
    char *err = biffGetDone(NRRD);

    sprintf(msg, "Error quantizing nrrd: %s", err);

    airMopAdd(mop, err, airFree, airMopAlways);
    airMopError(mop);

    throw LSPException(msg, "anim.cpp", "anim");
  }

  auto avg_x_q1 = std::vector<Nrrd*>();

  for (size_t i = 0; i < max_x_frames.size(); i++) {
    Nrrd* tmp = nrrdNew();
    airMopAdd(mop, tmp, airMopper(nrrdNuke), airMopAlways);

    nrrdSlice(tmp1, tmp, 2, i);

    avg_x_q1.push_back(tmp);
  }

}